<!DOCTYPE html>
<html lang="zh-CN">
<head>
	<meta charset="utf-8">
	<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, viewport-fit=cover">
	<meta name="apple-mobile-web-app-capable" content="yes">
	<meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
	<title>3D粒子手势交互系统</title>
	<style>
		* {
			margin: 0;
			padding: 0;
			box-sizing: border-box;
			-webkit-tap-highlight-color: transparent;
		}

		body {
			overflow: hidden;
			font-family: 'Arial', sans-serif;
			background: #000;
			position: fixed;
			width: 100%;
			height: 100%;
			touch-action: none;
		}

		#canvas-container {
			position: absolute;
			top: 0;
			left: 0;
			width: 100%;
			height: 100%;
		}

		#video {
			position: absolute;
			top: 0;
			left: 0;
			width: 100%;
			height: 100%;
			object-fit: cover;
			transform: scaleX(-1);
			opacity: 0.2;
			z-index: 1;
			pointer-events: none;
		}

		#controls {
			position: absolute;
			top: 10px;
			right: 10px;
			left: 10px;
			z-index: 100;
			background: rgba(0, 0, 0, 0.8);
			padding: 15px;
			border-radius: 10px;
			color: white;
			backdrop-filter: blur(10px);
			-webkit-backdrop-filter: blur(10px);
		}

		@media (min-width: 768px) {
			#controls {
				left: auto;
				width: auto;
				min-width: 250px;
				top: 20px;
				right: 20px;
				padding: 20px;
			}
		}

		#controls h3 {
			margin-bottom: 10px;
			font-size: 16px;
		}

		@media (min-width: 768px) {
			#controls h3 {
				font-size: 18px;
				margin-bottom: 15px;
			}
		}

		.color-picker-container {
			margin-bottom: 10px;
		}

		.color-picker-container label {
			display: block;
			margin-bottom: 5px;
			font-size: 12px;
		}

		@media (min-width: 768px) {
			.color-picker-container label {
				font-size: 14px;
			}
		}

		#colorPicker {
			width: 100%;
			height: 35px;
			border: none;
			border-radius: 5px;
			cursor: pointer;
			-webkit-appearance: none;
		}

		@media (min-width: 768px) {
			#colorPicker {
				height: 40px;
			}
		}

		#status {
			margin-top: 10px;
			font-size: 11px;
			color: #0f0;
			word-break: break-word;
		}

		@media (min-width: 768px) {
			#status {
				font-size: 12px;
				margin-top: 15px;
			}
		}

		#fingerCount {
			margin-top: 8px;
			font-size: 14px;
			color: #ff0;
			font-weight: bold;
		}

		@media (min-width: 768px) {
			#fingerCount {
				font-size: 16px;
				margin-top: 10px;
			}
		}

		/* 移动端优化 */
		@media (max-width: 767px) {
			#controls {
				font-size: 12px;
			}
		}
	</style>
</head>
<body>
	<div id="canvas-container"></div>
	<video id="video" autoplay playsinline></video>
	
	<div id="controls">
		<h3>控制面板</h3>
		<div class="color-picker-container">
			<label for="colorPicker">粒子颜色：</label>
			<input type="color" id="colorPicker" value="#00ff00">
		</div>
		<div id="fingerCount">检测手指数: 0</div>
		<div id="status">正在初始化摄像头...</div>
	</div>

	<script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
	<script src="https://cdn.jsdelivr.net/npm/@mediapipe/hands@0.4.1675469404/hands.js"></script>
	<script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils@0.3.1640029074/camera_utils.js"></script>
	<script src="https://cdn.jsdelivr.net/npm/@mediapipe/drawing_utils@0.3.1620248257/drawing_utils.js"></script>

	<script>
		// 检测移动设备
		const isMobile = /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent);
		const isIOS = /iPad|iPhone|iPod/.test(navigator.userAgent);
		
		// 根据设备调整粒子数量
		let particleCount = isMobile ? 5000 : 10000;
		
		// 全局变量
		let scene, camera, renderer;
		let particles, particleSystem;
		let hands;
		let videoElement;
		let currentColor = new THREE.Color(0x00ff00);
		let currentMode = 'normal'; // normal, text1, text2, text3, text4, follow
		let targetText = '';
		let textParticles = [];
		let fingerPositions = [];
		let videoWidth, videoHeight;

		// 初始化Three.js场景
		function initThreeJS() {
			scene = new THREE.Scene();
			camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
			camera.position.z = 1000;

			// 移动设备优化：降低抗锯齿和像素比
			const pixelRatio = isMobile ? Math.min(window.devicePixelRatio, 2) : window.devicePixelRatio;
			renderer = new THREE.WebGLRenderer({ 
				antialias: !isMobile, 
				alpha: true,
				powerPreference: "high-performance"
			});
			renderer.setSize(window.innerWidth, window.innerHeight);
			renderer.setPixelRatio(pixelRatio);
			document.getElementById('canvas-container').appendChild(renderer.domElement);

			// 创建粒子系统
			const geometry = new THREE.BufferGeometry();
			const positions = new Float32Array(particleCount * 3);
			const colors = new Float32Array(particleCount * 3);
			const sizes = new Float32Array(particleCount);

			for (let i = 0; i < particleCount; i++) {
				const i3 = i * 3;
				positions[i3] = (Math.random() - 0.5) * 2000;
				positions[i3 + 1] = (Math.random() - 0.5) * 2000;
				positions[i3 + 2] = (Math.random() - 0.5) * 2000;

				colors[i3] = currentColor.r;
				colors[i3 + 1] = currentColor.g;
				colors[i3 + 2] = currentColor.b;

				sizes[i] = Math.random() * 5 + 2;
			}

			geometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
			geometry.setAttribute('color', new THREE.BufferAttribute(colors, 3));
			geometry.setAttribute('size', new THREE.BufferAttribute(sizes, 1));

			const material = new THREE.ShaderMaterial({
				uniforms: {
					time: { value: 0 },
					color: { value: currentColor }
				},
				vertexShader: `
					attribute float size;
					attribute vec3 color;
					varying vec3 vColor;
					uniform float time;
					
					void main() {
						vColor = color;
						vec4 mvPosition = modelViewMatrix * vec4(position, 1.0);
						gl_PointSize = size * (300.0 / -mvPosition.z);
						gl_Position = projectionMatrix * mvPosition;
					}
				`,
				fragmentShader: `
					varying vec3 vColor;
					
					void main() {
						float distanceToCenter = distance(gl_PointCoord, vec2(0.5));
						float alpha = 1.0 - smoothstep(0.0, 0.5, distanceToCenter);
						gl_FragColor = vec4(vColor, alpha);
					}
				`,
				vertexColors: true,
				transparent: true,
				depthWrite: false
			});

			particleSystem = new THREE.Points(geometry, material);
			scene.add(particleSystem);
			particles = positions;
		}

		// 创建文字粒子
		function createTextParticles(text) {
			const canvas = document.createElement('canvas');
			const ctx = canvas.getContext('2d');
			canvas.width = 512;
			canvas.height = 512;
			
			ctx.fillStyle = 'white';
			ctx.font = 'bold 120px Arial';
			ctx.textAlign = 'center';
			ctx.textBaseline = 'middle';
			ctx.fillText(text, canvas.width / 2, canvas.height / 2);

			const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
			const data = imageData.data;
			textParticles = [];

			for (let y = 0; y < canvas.height; y += 4) {
				for (let x = 0; x < canvas.width; x += 4) {
					const index = (y * canvas.width + x) * 4;
					if (data[index + 3] > 128) {
						textParticles.push({
							x: (x - canvas.width / 2) * 2,
							y: -(y - canvas.height / 2) * 2,
							z: 0
						});
					}
				}
			}

			return textParticles;
		}

		// 更新粒子位置到文字
		function updateParticlesToText(textParticles) {
			const positions = particleSystem.geometry.attributes.position.array;
			const targetCount = Math.min(textParticles.length, particleCount);
			const lerpSpeed = isMobile ? 0.08 : 0.1;

			for (let i = 0; i < particleCount; i++) {
				const i3 = i * 3;
				if (i < targetCount) {
					const target = textParticles[i];
					positions[i3] += (target.x - positions[i3]) * lerpSpeed;
					positions[i3 + 1] += (target.y - positions[i3 + 1]) * lerpSpeed;
					positions[i3 + 2] += (target.z - positions[i3 + 2]) * lerpSpeed;
				} else {
					// 其他粒子散开
					positions[i3] += ((Math.random() - 0.5) * 2000 - positions[i3]) * 0.05;
					positions[i3 + 1] += ((Math.random() - 0.5) * 2000 - positions[i3 + 1]) * 0.05;
					positions[i3 + 2] += ((Math.random() - 0.5) * 2000 - positions[i3 + 2]) * 0.05;
				}
			}

			particleSystem.geometry.attributes.position.needsUpdate = true;
		}

		// 更新粒子跟随手指
		function updateParticlesFollowFingers(fingerPositions) {
			const positions = particleSystem.geometry.attributes.position.array;
			const particlesPerFinger = Math.floor(particleCount / fingerPositions.length);
			const lerpSpeed = isMobile ? 0.12 : 0.15;

			for (let i = 0; i < particleCount; i++) {
				const i3 = i * 3;
				const fingerIndex = Math.floor(i / particlesPerFinger);
				
				if (fingerIndex < fingerPositions.length && fingerPositions[fingerIndex]) {
					const finger = fingerPositions[fingerIndex];
					// 将屏幕坐标转换为3D坐标
					const x = (finger.x - 0.5) * 2000;
					const y = -(finger.y - 0.5) * 2000;
					const z = finger.z * 1000 - 500;

					positions[i3] += (x - positions[i3]) * lerpSpeed;
					positions[i3 + 1] += (y - positions[i3 + 1]) * lerpSpeed;
					positions[i3 + 2] += (z - positions[i3 + 2]) * lerpSpeed;
				} else {
					// 散开效果
					positions[i3] += ((Math.random() - 0.5) * 2000 - positions[i3]) * 0.1;
					positions[i3 + 1] += ((Math.random() - 0.5) * 2000 - positions[i3 + 1]) * 0.1;
					positions[i3 + 2] += ((Math.random() - 0.5) * 2000 - positions[i3 + 2]) * 0.1;
				}
			}

			particleSystem.geometry.attributes.position.needsUpdate = true;
		}

		// 更新粒子缩放
		function updateParticleScale(scale) {
			const positions = particleSystem.geometry.attributes.position.array;
			const center = new THREE.Vector3(0, 0, 0);

			for (let i = 0; i < particleCount; i++) {
				const i3 = i * 3;
				const currentPos = new THREE.Vector3(positions[i3], positions[i3 + 1], positions[i3 + 2]);
				const direction = currentPos.clone().sub(center).normalize();
				const distance = currentPos.distanceTo(center);
				const targetDistance = distance * scale;

				positions[i3] += (center.x + direction.x * targetDistance - positions[i3]) * 0.1;
				positions[i3 + 1] += (center.y + direction.y * targetDistance - positions[i3 + 1]) * 0.1;
				positions[i3 + 2] += (center.z + direction.z * targetDistance - positions[i3 + 2]) * 0.1;
			}

			particleSystem.geometry.attributes.position.needsUpdate = true;
		}

		// 更新粒子颜色
		function updateParticleColor(color) {
			currentColor = color;
			const colors = particleSystem.geometry.attributes.color.array;

			for (let i = 0; i < particleCount; i++) {
				const i3 = i * 3;
				colors[i3] = color.r;
				colors[i3 + 1] = color.g;
				colors[i3 + 2] = color.b;
			}

			particleSystem.geometry.attributes.color.needsUpdate = true;
			particleSystem.material.uniforms.color.value = color;
		}

		// 计算手指数量
		function countFingers(landmarks) {
			const fingerTips = [4, 8, 12, 16, 20]; // 拇指、食指、中指、无名指、小指
			const fingerPips = [3, 6, 10, 14, 18]; // 对应的关节
			let count = 0;

			// 检查拇指（特殊处理，因为它是横向的）
			if (landmarks[4].x > landmarks[3].x) {
				count++;
			}

			// 检查其他四个手指
			for (let i = 1; i < 5; i++) {
				if (landmarks[fingerTips[i]].y < landmarks[fingerPips[i]].y) {
					count++;
				}
			}

			return count;
		}

		// 获取手指位置
		function getFingerPositions(landmarks) {
			const fingerTips = [4, 8, 12, 16, 20];
			const positions = [];

			for (let i = 0; i < fingerTips.length; i++) {
				const tip = landmarks[fingerTips[i]];
				positions.push({
					x: tip.x,
					y: tip.y,
					z: tip.z
				});
			}

			return positions;
		}

		// 计算手部缩放
		function calculateHandScale(landmarks) {
			// 使用手腕到中指的距离作为基准
			const wrist = landmarks[0];
			const middleFinger = landmarks[9];
			const distance = Math.sqrt(
				Math.pow(wrist.x - middleFinger.x, 2) +
				Math.pow(wrist.y - middleFinger.y, 2)
			);
			return distance * 10; // 调整缩放因子
		}

		// 初始化MediaPipe Hands
		function initHandTracking() {
			videoElement = document.getElementById('video');

			hands = new Hands({
				locateFile: (file) => {
					return `https://cdn.jsdelivr.net/npm/@mediapipe/hands/${file}`;
				}
			});

			// 移动设备使用更低的模型复杂度以提高性能
			hands.setOptions({
				maxNumHands: 2,
				modelComplexity: isMobile ? 0 : 1,
				minDetectionConfidence: 0.5,
				minTrackingConfidence: 0.5
			});

			hands.onResults(onHandResults);

			// 根据设备调整视频尺寸
			if (isMobile) {
				// 移动设备使用较小的分辨率以提高性能
				videoWidth = 320;
				videoHeight = 240;
			} else {
				videoWidth = 640;
				videoHeight = 480;
			}

			const camera = new Camera(videoElement, {
				onFrame: async () => {
					await hands.send({ image: videoElement });
				},
				width: videoWidth,
				height: videoHeight,
				facingMode: 'user' // 使用前置摄像头
			});

			camera.start().then(() => {
				const deviceInfo = isMobile ? '（移动设备模式）' : '';
				document.getElementById('status').textContent = `摄像头已启动，请将手放在摄像头前${deviceInfo}`;
			}).catch(err => {
				let errorMsg = '摄像头启动失败: ' + err.message;
				if (isMobile) {
					errorMsg += '。请确保已授予摄像头权限，并尝试刷新页面。';
				} else {
					errorMsg += '。请确保已授予摄像头权限。';
				}
				document.getElementById('status').textContent = errorMsg;
				console.error('摄像头启动失败:', err);
			});
		}

		// 处理手部检测结果（节流处理以提高性能）
		let lastHandUpdate = 0;
		const handUpdateInterval = isMobile ? 100 : 50; // 移动设备降低更新频率

		function onHandResults(results) {
			const now = Date.now();
			if (now - lastHandUpdate < handUpdateInterval) {
				return;
			}
			lastHandUpdate = now;

			if (results.multiHandLandmarks && results.multiHandLandmarks.length > 0) {
				// 使用第一只手
				const landmarks = results.multiHandLandmarks[0];
				const fingerCount = countFingers(landmarks);
				
				document.getElementById('fingerCount').textContent = `检测手指数: ${fingerCount}`;

				// 根据手指数量切换模式
				if (fingerCount === 1) {
					currentMode = 'zoom';
					const scale = calculateHandScale(landmarks);
					updateParticleScale(scale);
				} else if (fingerCount === 2) {
					currentMode = 'text1';
					if (targetText !== '我在中山很想你') {
						targetText = '我在中山很想你';
						createTextParticles(targetText);
					}
					updateParticlesToText(textParticles);
				} else if (fingerCount === 3) {
					currentMode = 'text2';
					if (targetText !== 'HI') {
						targetText = 'HI';
						createTextParticles(targetText);
					}
					updateParticlesToText(textParticles);
				} else if (fingerCount === 4) {
					currentMode = 'text3';
					if (targetText !== "I'am HaoRan") {
						targetText = "I'am HaoRan";
						createTextParticles(targetText);
					}
					updateParticlesToText(textParticles);
				} else if (fingerCount === 5) {
					currentMode = 'follow';
					fingerPositions = getFingerPositions(landmarks);
					updateParticlesFollowFingers(fingerPositions);
				} else {
					currentMode = 'normal';
				}

				// 双手张合控制缩放
				if (results.multiHandLandmarks.length === 2) {
					const hand1 = results.multiHandLandmarks[0];
					const hand2 = results.multiHandLandmarks[1];
					const wrist1 = hand1[0];
					const wrist2 = hand2[0];
					
					const distance = Math.sqrt(
						Math.pow(wrist1.x - wrist2.x, 2) +
						Math.pow(wrist1.y - wrist2.y, 2)
					);
					
					const scale = distance * 5;
					updateParticleScale(scale);
				}
			} else {
				document.getElementById('fingerCount').textContent = '检测手指数: 0';
				currentMode = 'normal';
			}
		}

		// 动画循环
		let lastTime = 0;
		const targetFPS = isMobile ? 30 : 60;
		const frameInterval = 1000 / targetFPS;

		function animate(currentTime) {
			requestAnimationFrame(animate);

			const deltaTime = currentTime - lastTime;
			
			// 移动设备限制帧率
			if (isMobile && deltaTime < frameInterval) {
				return;
			}

			lastTime = currentTime;

			// 旋转粒子系统
			if (currentMode === 'normal') {
				particleSystem.rotation.y += isMobile ? 0.0005 : 0.001;
			}

			// 更新着色器时间
			particleSystem.material.uniforms.time.value += isMobile ? 0.005 : 0.01;

			renderer.render(scene, camera);
		}

		// 颜色选择器事件
		document.getElementById('colorPicker').addEventListener('input', (e) => {
			const color = new THREE.Color(e.target.value);
			updateParticleColor(color);
		});

		// 窗口大小调整
		function handleResize() {
			camera.aspect = window.innerWidth / window.innerHeight;
			camera.updateProjectionMatrix();
			renderer.setSize(window.innerWidth, window.innerHeight);
		}

		window.addEventListener('resize', handleResize);
		
		// 移动设备方向变化处理
		if (isMobile) {
			window.addEventListener('orientationchange', () => {
				setTimeout(() => {
					handleResize();
				}, 100);
			});
		}

		// 防止移动端页面缩放
		document.addEventListener('touchstart', function(event) {
			if (event.touches.length > 1) {
				event.preventDefault();
			}
		}, { passive: false });

		let lastTouchEnd = 0;
		document.addEventListener('touchend', function(event) {
			const now = Date.now();
			if (now - lastTouchEnd <= 300) {
				event.preventDefault();
			}
			lastTouchEnd = now;
		}, false);

		// 初始化
		initThreeJS();
		initHandTracking();
		animate();
	</script>
</body>
</html>


